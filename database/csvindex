#!/usr/bin/python

import argparse
import collections
import csv
import os
import sys

def comma_separated(s):
    return s.split(',')

parser = argparse.ArgumentParser(
        description='Create a CSV file which serves as an index')
parser.add_argument('-e', '--extra', help='extra fields to include',
                    type=comma_separated, default=[])
parser.add_argument('-o', '--order', help='extra fields to include',
                    type=comma_separated, default=[])
parser.add_argument('-r', '--relational', help='whether the index is relational', action='store_true', default=False)
parser.add_argument('csv_name', help='name of the input CSV (without .csv)')
parser.add_argument('fields', help='fields to index', type=comma_separated)
parser.add_argument('index_name', help='name of the output index')
args = parser.parse_args()

out_csv = '%s-index-%d-%d-%d.csv' % \
        (args.index_name, len(args.fields), len(args.order) + 1, len(args.extra))
out_csv = os.path.join('csv', out_csv)
if os.path.isfile(out_csv):
    sys.stderr.write("%s already exists\n" % out_csv)
    sys.exit(0)

output = collections.defaultdict(lambda: [])
with open(os.path.join('csv', args.csv_name + '.csv'), 'r') as csv_file:
    reader = csv.reader(csv_file,
            delimiter=',', quotechar='\'', escapechar='\\')
    header = reader.next()

    # Ensure we include the ID in the order key
    id_name = next(field for field in header if field.endswith('_id') or field == 'id')
    try:
        args.extra.remove(id_name)
    except ValueError:
        pass

    if not args.relational:
        args.order.append(id_name)

    field_indices = map(lambda f: header.index(f), args.fields)
    order_indices = map(lambda f: header.index(f), args.order)
    extra_indices = map(lambda f: header.index(f), args.extra)

    # Collect all indexed fields
    for row in reader:
        row_fields = tuple([row[i] for i in field_indices])
        row_order = tuple([row[i] for i in order_indices])

        if args.relational:
            output[(row_fields, row_order)].append(int(row[0]))
        else:
            extra_fields = tuple([row[i] for i in extra_indices])
            output[(row_fields, row_order)].append(extra_fields)

with open(out_csv, 'w') as index_file:
    writer = csv.writer(index_file,
            delimiter=',', quotechar='\'', escapechar='\\')

    # Add a header if we're collecting more than IDs
    if not args.relational:
        writer.writerow(args.fields + list(args.order) + args.extra)

    # Write each set of keys
    for (keys, order), row_data in output.iteritems():
        if args.relational:
            writer.writerow(keys + order + tuple(row_data))
        else:
            for fields in row_data:
                writer.writerow(keys + order + fields)
